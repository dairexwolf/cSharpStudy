// Для работы с бинарными файлами предназначена пара классов BinaryWriter и BinaryReader. Эти классы позволяют читать и записывать данные в двоичном формате.

/*
Основные метода класса BinaryWriter

- Close(): закрывает поток и освобождает ресурсы

- Flush(): очищает буфер, дописывая из него оставшиеся данные в файл

- Seek(): устанавливает позицию в потоке

- Write(): записывает данные в поток
*/

/*
Основные метода класса BinaryReader

- Close(): закрывает поток и освобождает ресурсы

- ReadBoolean(): считывает значение bool и перемещает указатель на один байт

- ReadByte(): считывает один байт и перемещает указатель на один байт

- ReadChar(): считывает значение char, то есть один символ, и перемещает указатель на столько байтов, сколько занимает символ в текущей кодировке

- ReadDecimal(): считывает значение decimal и перемещает указатель на 16 байт

- ReadDouble(): считывает значение double и перемещает указатель на 8 байт

- ReadInt16(): считывает значение short и перемещает указатель на 2 байта

- ReadInt32(): считывает значение int и перемещает указатель на 4 байта

- ReadInt64(): считывает значение long и перемещает указатель на 8 байт

- ReadSingle(): считывает значение float и перемещает указатель на 4 байта

- ReadString(): считывает значение string. Каждая строка предваряется значением длины строки, которое представляет 7-битное целое число
*/

// С чтением бинарных данных все просто: соответствующий метод считывает данные определенного типа и перемещает указатель на размер этого типа в байтах, например, значение типа int занимает 4 байта, поэтому BinaryReader считает 4 байта и переместит указатель на эти 4 байта.

// С чтением бинарных данных все просто: соответствующий метод считывает данные определенного типа и перемещает указатель на размер этого типа в байтах, например, значение типа int занимает 4 байта, поэтому BinaryReader считает 4 байта и переместит указать на эти 4 байта.

// Посмотрим на реальной задаче применение этих классов. Попробуем с их помощью записывать и считывать из файла массив структур:

struct State
{
	public string name;
	public string capital;
	public int area;
	public double people;
	
	public State (string name, string capital, int area, double people)
	{
		this.name = name;
		this.capital = capital;
		this.people = people;
		this.area = area;
	}
}

class Program
{
	static void Main()
	{
		State[] states = new State[2];
		states[0] = new State("Germany","Berlin", 357168, 80.8);
		states[1] = new State("Франция","ВиваЛяДеПариж", 640679, 64.7);
		
		string path = @"C:\SomeDir\states.dat";
		
		try
		{
			// создаем объект BinaryWriter
			using (BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.OpenOrCreate)))
			{
				// записываем в файл значение каждого поля структуры
				foreach (State s in states)
				{
					writer.Write(s.name);
					writer.Write(s.capital);
					writer.Write(s.area);
					writer.Write(s.people);
				}
			}
			// создаем объект BinaryReader
			using (BinaryReader reader = new BinaryReader(File.Open(path, FileMode.Open)))
			{
				// пока не достигнут конце файла, считываем каждое значение из файла
				while (reader.PeekChar() > -1)
				{
					string name = reader.ReadString();
					string capital = reader.ReadString();
					int area = reader.ReadInt32();
					double population = reader.ReadDouble();
					
					Console.WriteLine($"Страна: {name}\t Столица: {capital}\tПлощадь: {area} кв.м \tчисленность населения: {population} млн. чел");
				}
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.Message);
		}
		finally
		{
			Console.ReadLine();
		}
	}
}

// Итак, у нас есть структура State с некоторым набором полей. В основной программе создаем массив структур и записываем с помощью BinaryWriter. Этот класс в качестве параметра в конструкторе принимает объект Stream, который создается вызовом File.Open(path, FileMode.OpenOrCreate).

// Затем в цикле пробегаемся по массиву структур и записываем каждое поле структуры в поток. В том порядке, в каком эти значения полей записываются, в том порядке они и будут размещаться в файле.

// Затем считываем из записанного файла. Конструктор класса BinaryReader также в качестве параметра принимает объект потока, только в данном случае устанавливаем в качестве режима FileMode.Open: new BinaryReader(File.Open(path, FileMode.Open))

// В цикле while считываем данные. Чтобы узнать окончание потока, вызываем метод PeekChar(). Этот метод считывает следующий символ и возвращает его числовое представление. Если символ отсутствует, то метод возвращает -1, что будет означать, что мы достигли конца файла.

// В цикле последовательно считываем значения поле структур в том же порядке, в каком они записывались.

// Таким образом, классы BinaryWriter и BinaryReader очень удобны для работы с бинарными файлами, особенно когда нам известна структура этих файлов. В то же время для хранения и считывания более комплексных объектов, например, объектов классов, лучше подходит другое решение - сериализация.