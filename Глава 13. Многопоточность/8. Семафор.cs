// Еще один инструмент, который предлагает нам платформа .NET для управления синхронизацией, представляют семафоры. Семафоры позволяют ограничить доступ определенным количеством объектов.
// Например, у нас такая задача: есть некоторое число читателей, которые приходят в библиотеку три раза в день и что-то там читают. И пусть у нас будет ограничение, что единовременно в библиотеке не может находиться больше трех читателей. Данную задачу очень легко решить с помощью семафоров:

//В данной программе читатель представлен классом Reader. Он инкапсулирует всю функциональность, связанную с потоками, через переменную Thread myThread.

class Program
{
	static void Main()
	{
		for (int i = 1; i < 6; i++)
		{
			Reader reader = new Reader(i);
		}
	}
}

class Reader
{
	// создаем семафор
	static Semaphore sem = new Semaphore(3, 3);
	Thread myThread;
	int count = 3;	// счетчик чтения
	
	public Reader (int i)
	{
		myThread = new Thread(Read);
		myThread.Name = $"Читатель {i.ToString()}";
		myThread.Start();
	}
	
	public void Read()
	{
		while (count > 0)
		{
		sem.WaitOne();
		Console.WriteLine($"{Thread.CurrentThread.Name} входит в библиотеку");
		Console.WriteLine($"{Thread.CurrentThread.Name} читает");
		Thread.Sleep(1000);
		Console.WriteLine($"{Thread.CurrentThread.Name} ушел");
		sem.Release();
		count--;
		Thread.Sleep(1000);
		}
	}
}

// Для создания семафора используется класс Semaphore: static Semaphore sem = new Semaphore(3, 3);. Его конструктор принимает два параметра: первый указывает, какому числу объектов изначально будет доступен семафор, а второй параметр указывает, какой максимальное число объектов будет использовать данный семафор. В данном случае у нас только три читателя могут одновременно находиться в библиотеке, поэтому максимальное число равно 3.

// Основной функционал сосредоточен в методе Read, который и выполняется в потоке. В начале для ожидания получения семафора используется метод sem.WaitOne(). После того, как в семафоре освободится место, данный поток заполняет свободное место и начинает выполнять все дальнейшие действия. После окончания чтения мы высвобождаем семафор с помощью метода sem.Release(). После этого в семафоре освобождается одно место, которое заполняет другой поток.

// А в методе Main нам остается только создать читателей, которые запускают соответствующие потоки.

// Автору следовало релизнуть семафор после Thread.Sleep(), тогда не складывалось бы ощущения что первый параметр передающийся в конструктор ничего не меняет. для всех страждующих скажу: первый параметр конструктора семафора - количество доступных мест на данный момент, второй параметр - количество доступных мест всего, то есть если сделать Semaphor sem = new Semaphor(2, 3) он будет обрабатывать только 2 потока одновременно, несмотря на то что может 3.