// Нередко в потоках используются некоторые разделяемые ресурсы, общие для всей программы. Это могут быть общие переменные, файлы, другие ресурсы. Например:

class Program
{
	static int x = 0;
	public static void Count()
	{
		x = 1;
		for(int i=1; i<9; i++)
		{
			Console.WriteLine("{0}: {1}", Thread.CurrentThread.Name, x);
			x++;
			Thread.Sleep(100);
		}
	}
	
	static voidn Main()
	{
		for (int i = 0; i<5; i++)
		{
			Thread myThread = new Thread(Count);
			Thread.Name = "Поток " + i.ToString();
			myThread.Start();
		}
		
	}
}

// Здесь у нас запускаются пять потоков, которые работают с общей переменной x. И мы предполагаем, что метод выведет все значения x от 1 до 8. И так для каждого потока. Однако в реальности в процессе работы будет происходить переключение между потоками, и значение переменной x становится непредсказуемым.

// Решение проблемы состоит в том, чтобы синхронизировать потоки и ограничить доступ к разделяемым ресурсам на время их использования каким-нибудь потоком.
// Для этого используется ключевое слово lock. Оператор lock определяет блок кода, внутри которого весь код блокируется и становится недоступным для других потоков до завершения работы текущего потока. И мы можем переделать предыдущий пример следующим образом:

class Program
{
	static int x = 0;
	// Для блокировки с ключевым словом lock используется объект-заглушка, в данном случае это переменная locker. Когда выполнение доходит до оператора lock, объект locker блокируется, и на время его блокировки монопольный доступ к блоку кода имеет только один поток. После окончания работы блока кода, объект locker освобождается и становится доступным для других потоков.
	static object locker = new object();
	public static void  Count()
	{
		lock (locker)
		{
			x = 1;
			for (int i=1; i<9;i++)
			{
				Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
				x++;
				Thread.Sleep(100);
			}
		}
	}
	
	public void Main()
	{
		for (int i = 1; i<5; i++)
		{
			Thread myThread = new Thread(Count);
			myThread.Name = "Поток " + i.ToString();
			myThread.Start();
		}
	}
}