// Основная функциональность регулярных выражений в .NET сосредоточена в пространстве имен System.Text.RegularExpressions. А центральным классом при работе с регулярными выражениями является класс Regex.
// Например, у нас есть некоторый текст и нам надо найти в нем все словоформы какого-нибудь слова. С классом Regex это сделать очень просто:
using System.Text.RegularExpressions;	// в этой библиотеке находится класс Regex

string s = "Бык тупогуб, тупогубенький бычок, у быка бела губа была тупа";
Regex regex = new Regex(@"туп(\w*)");
MatchCollection matches = regex.Matches(s);	// Метод Matches класса Regex принимает строку, к которой надо применить регулярные выражения, и возвращает коллекцию найденных совпадений.
if (matches.Count > 0)
{
	foreach (Match match in matches)
		Console.WriteLine(match.Value);		//Каждый элемент такой коллекции представляет объект Match. Его свойство Value возвращает найденное совпадение.
}
else
	Console.WriteLine("Нет совпадений");

// Здесь мы находим в искомой строке все словоформы слова "туп". В конструктор объекта Regex передается регулярное выражение для поиска. Выражение туп(\w*) обозначает, найти все слова, которые имеют корень "туп" и после которого может стоять различное количество символов. Выражение \w означает алфавитно-цифровой символ, а звездочка после выражения указывает на неопределенное их количество - их может быть один, два, три или вообще не быть.

// 												Параметр RegexOptions
// Класс Regex имеет ряд конструкторов, позволяющих выполнить начальную инициализацию объекта. Две версии конструкторов в качестве одного из параметров принимают перечисление RegexOptions.
/*
 Некоторые из значений, принимаемых данным перечислением:
	
	Compiled: при установке этого значения регулярное выражение компилируется в сборку, что обеспечивает более быстрое выполнение

	CultureInvariant: при установке этого значения будут игнорироваться региональные различия

	IgnoreCase: при установке этого значения будет игнорироваться регистр

	IgnorePatternWhitespace: удаляет из строки пробелы и разрешает комментарии, начинающиеся со знака #

	Multiline: указывает, что текст надо рассматривать в многострочном режиме. При таком режиме символы "^" и "$" совпадают, соответственно, с началом и концом любой строки, а не с началом и концом всего текста

	RightToLeft: приписывает читать строку справа налево

	Singleline: устанавливает однострочный режим, а весь текст рассматривается как одна строка
*/
// Пример:
Regex regex = new Regex(@"туп(\w*)", RegexOptions.IgnoreCase);	// регистр игнорируется
// Можно установить несколько параметров
Regex regex = new Regex(@"туп(\w*)", RegexOptions.Compiled | RgrxOptions.IgnoreCase);

// Повторяем синтаксис
/*
Рассмотрим вкратце некоторые элементы синтаксиса регулярных выражений:

	^: соответствие должно начинаться в начале строки (например, выражение @"^пр\w*" соответствует слову "привет" в строке "привет мир")

	$: конец строки (например, выражение @"\w*ир$" соответствует слову "мир" в строке "привет мир", так как часть "ир" находится в самом конце)

	.: знак точки определяет любой одиночный символ (например, выражение "м.р" соответствует слову "мир" или "мор")

	*: предыдущий символ повторяется 0 и более раз

	+: предыдущий символ повторяется 1 и более раз

	?: предыдущий символ повторяется 0 или 1 раз

	\s: соответствует любому пробельному символу

	\S: соответствует любому символу, не являющемуся пробелом

	\w: соответствует любому алфавитно-цифровому символу

	\W: соответствует любому не алфавитно-цифровому символу

	\d: соответствует любой десятичной цифре

	\D : соответствует любому символу, не являющемуся десятичной цифрой

Все элементы: https://docs.microsoft.com/ru-ru/dotnet/standard/base-types/regular-expression-language-quick-reference?redirectedfrom=MSDN
*/

// Возьмем первый пример с скороговоркой "Бык тупогуб, тупогубенький бычок, у быка губа бела была тупа" и найдем в ней все слова, где встречается корень "губ":

string s = "Бык тупогуб, тупогубенький бычок, у быка бела губа была тупа";
Regex regex = new Regex (@"\w*губ\w*");	
// Так как выражение \w* соответствует любой последовательности алфавитно-цифровых символов любой длины, то данное выражение найдет все слова, содержащие корень "губ".

// Второй простенький пример - нахождение телефонного номера в формате 111-111-1111:

string s = "456-435-2318";
Regex regex = new Regex(@"\d{3}-\d{3}-\d{4}");
// Если мы точно знаем, сколько определенных символов должно быть, то мы можем явным образом указать их количество в фигурных скобках: \d{3} - то есть в данном случае три цифры.

// Мы можем не только задать поиск по определенным типам символов - пробелы, цифры, но и задать конкретные символы, которые должны входить в регулярное выражение. Например, перепишем пример с номером телефона и явно укажем, какие символы там должны быть:

string s = "456-435-2318";
Regex regex = new Regex([0-9]{3}-[0-9]{3}-[0-9]{4});
// В квадратных скобках задается диапазон символов, которые должны в данном месте встречаться. В итоге данный и предыдущий шаблоны телефонного номера будут эквивалентны.

// Также можно задать диапазон для алфавитных символов:
string str = "Nigga";
Regex regex = new Regex(@"[A-Na-n]{5}");	// - данное выражение будет соответствовать любому сочетанию пяти символов, в котором все символы находятся в диапазоне от A до N и от a до n.

// Можно также указать отдельные значения:
string s = "222-435-2318";
Regex regex = new Regex(@"[2]{3}-[0-9]{3}-[0-9]{4}");

// С помощью операции | можно задать альтернативные символы:

string s = "232-345-1234";
Regex regex = new Regex(@"[2\|3]{3}-[0-9]{3}-\d{4}");
// Первые три цифры могут содержать только двойки или тройки. Такой шаблон будет соответствовать, например, строкам "222-222-2222" и "323-435-2318". А вот строка "235-435-2318" уже не подпадает под шаблон, так как одной из трех первых цифр является цифра 5.

// Итак, у нас такие символы, как *, + и ряд других используются в качестве специальных символов. И возникает вопрос, а что делать, если нам надо найти, строки, где содержится точка, звездочка или какой-то другой специальный символ? В этом случае нам надо просто экранировать эти символы слешем:

string s = "2\|3.333.4567";
Regex regex = new Regex(@"[2|3]{3}\.[0-9]{3}\.\d{4}");

//													Проверка на соответствие строки формату
// Нередко возникает задача проверить корректность данных, введенных пользователем. Это может быть проверка электронного адреса, номера телефона.
// Класс Regex предоставляет статический метод IsMatch, который позволяет проверить входную строку с шаблоном на соответствие:

string pattern = @"^(?("")(""[^""]+?""@)|(([0-9a-z]((\.(?!\.))|[-!#\$%&'\*\+/=\?\^`\{\}\|~\w])*)(?<=[0-9a-z])@))" +
                @"(?(\[)(\[(\d{1,3}\.){3}\d{1,3}\])|(([0-9a-z][-\w]*[0-9a-z]*\.)+[a-z0-9]{2,17}))$";
// Переменная pattern задает регулярное выражение для проверки адреса электронной почты. Данное выражение предлагает нам Microsoft на страницах msdn.
string email = xaxaloh;

while (true)
{

	Console.WriteLine($"Адрес эл.почты: {email}");
	if (Regex.IsMatch(email, pattern, RegexOptions.IgnoreCase))
	// Статическая функция
	// email - введенная строка, pattern - регулярное выражение, опции)
	{
		Console.WriteLine("Подтвержденная электронная почта: "+email);
		break;
	}
	else
	{
		Console.WriteLine("Некорректный email");
		email = "sobaka@nigga.nib";
	}
}
// Для проверки соответствия строки шаблону используется метод IsMatch: Regex.IsMatch(email, pattern, RegexOptions.IgnoreCase). Последний параметр указывает, что регистр можно игнорировать. И если введенная строка соответствует шаблону, то метод возвращает true.

//												Замена и метод Replace
//Класс Regex имеет метод Replace, который позволяет заменить строку, соответствующую регулярному выражению, другой строкой:

string str = "Мама                мыла              раму.                ";
Console.WriteLine(str);
string pattern = @"\s+";
string target = " ";
Regex regex = new Regex(pattern);
str = regex.Replace(str, target);
Console.WriteLine(str);

//Данная версия метода Replace принимает два параметра: строку с текстом, где надо выполнить замену, и сама строка замены. Так как в качестве шаблона выбрано выражение "\s+ (то есть наличие одного и более пробелов), метод Replace проходит по всему тексту и заменяет несколько подряд идущих пробелов ординарными.
//												Очень нужная в будущем вещь!