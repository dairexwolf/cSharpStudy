// В предыдущих главах мы работали непосредственно с окном приложения, которое представлено классом Window, его разметкой, добавляли в нее элементы, создавали для него код на C#. Однако само приложение начинается не с класса Window, а с класса Application. По умолчанию при создании проекта WPF создается файл App.xaml и класс связанного кода App.xaml.cs
// Файл App.xaml выглядит примерно так:
<Application x:Class="LifecycleApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:LifecycleApp"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>

// С помощью атрибута x:Class элемент Application задает полное название производного класса приложения. По умолчанию класс называется App, с указанием названия проекта, то есть в данном случае LifecycleApp.App

// Как правило, основная задача данного файла состоит в определении ресурсов, общих для приложения. Поэтому тут по умолчанию определен пустой элемент Application.Resources, в который, собственно, и помещаются ресурсы.

// Также здесь декларативным путем можно прикрепить к событиям приложения обработчики.

// С помощью атрибута StartupUri устанавливается путь к разметке xaml, с которого начинается выполнение приложения. По умолчанию это разметка окна MainWindow, определенного в файле MainWindow.xaml. Если у нас в приложении несколько окон, тут мы можем указать то, которое будет запускаться при вызове приложения.

// Файл App.xaml.cs также содержит определение класса App. По умолчанию этот класс совершенно пустой:
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

namespace LifecycleApp
{
    /// <summary>
    /// Логика взаимодействия для App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}

// В нем мы можем задать обработчики событий приложения, либо какую-то другую глобальную для всего приложения логику.

// Таким образом, у нас получается, что оба файла App.xaml и App.xaml.cs содержат определение одного и тоже класса App. Однако в конечном счете они будут компилироваться в один файл приложения App.g.cs, который вы можете найти после компиляции приложения в каталоге проекта obj/Debug и который будет выглядеть примерно так:
#pragma checksum "..\..\App.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "2997C692E37FCE9FAAB9293ED4F90EC78CBD6BE6"
//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан программой.
//     Исполняемая версия:4.0.30319.42000
//
//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
//     повторной генерации кода.
// </auto-generated>
//------------------------------------------------------------------------------

using LifecycleApp;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace LifecycleApp {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public void InitializeComponent() {
            
            #line 5 "..\..\App.xaml"
            this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public static void Main() {
            LifecycleApp.App app = new LifecycleApp.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}

// Входной точкой в программу (как и в любое другое приложение на C#) является метод Main, в котором создается экземпляр приложения и производится начальная инициализация и вызов главного окна программы.

// Так как WPF требует, чтобы главный поток работал в однопоточном подразделении (Single-threaded apartment), то метод Main помечается атрибутом STAThreadAttribute. Однопоточное подразделение содержит один поток, в данном случае главный. Это означает, что к элементам, созданным в этом потоке можно обратиться только из этого же потока. В то же время WPF предлагает эффективный способ взаимодействия между потоками, о котором мы позже поговорим.

// С помощью метода InitializeComponent происходит инициализация приложение: установка главного окна для запуска. И далее само приложение запускается через вызов app.Run().

// Однако это не жестко заданная организация файлов приложения, и мы ее можем переопределить и установить точку входа в приложение сами. Для этого, во-первых, изменим код App.xaml.cs:
namespace LifecycleApp
{
    /// <summary>
    /// Логика взаимодействия для App.xaml
    /// </summary>
    public partial class App : Application
    {
        App()
        {
            InitializeComponent();
        }

        [STAThread]
        static void Main()
        {
            App app = new App();
            MainWindow window = new MainWindow();
            app.Run(window);
        }
    }
}

// Фактически файл App.xaml.cs стал похож на компилируемый файл App.g.cs. Здесь мы сразу определяем метод Main и запускаем главное окно MainWindow.

// После этого изменим файл App.xaml следующим образом:
<Application x:Class="LifecycleApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:LifecycleApp"
             
    <Application.Resources>
    <Style TargetType="Grid">
        <Setter Property="Background" Value="Gray" />
    </Style>
    </Application.Resources>
</Application>

// В данном случае убран атрибут StartupUri, так как главное окно приложения теперь запускается из самого класса, и определен стиль для элемента Grid, который по умолчанию имеется в MainWindow.xaml.

// Далее в окне свойств для файла App.xaml изменим значение в поле Build Action на Page
// И после запуска нам отобразится окно с гридом, окрашенным в серый цвет.







