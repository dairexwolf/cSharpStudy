// Атрибуты в .NET представляют специальные инструменты, которые позволяют встраивать в сборку дополнительные метаданные. Атрибуты могут применяться как ко всему типу (классу, интерфейсу и т.д.), так и к отдельным его частям (методу, свойству и т.д.). Основу атрибутов составляет класс System.Attribute, от которого образованы все остальные классы атрибутов.

// В .NET имеется множество различных классов атрибутов. Например, при сериализации в различные форматы используются атрибуты [Serializable] и [NonSerialized]. С помощью рефлексии стандартные классы .NET получают использованные атрибуты и производят определенные действия.
// Например, атрибут [Serializable] указывает классу BinaryFormatter, что объекты с данным атрибутом можно сохранять в бинарный файл. В то ж время пока к классу с атрибутом не применена рефлексия, атрибут не размещается в памяти, и никакого влияния на данный класс не оказывает.

// Допустим, нам надо проверять пользователя на соответствие некоторым возрастным ограничениям. Создадим свой атрибут, который будет хранить пороговое значение возраста, с которого разрешены некоторые действия:

public class AgeValidationAttribute : System.Attribute
{
	public int Age { get; set; }
	
	public AgeValidationAttribute()
	{}
	
	public AgeValidationAttribute(int age)
	{
		Age = age;
	}
}
// По сути это обычный класс, унаследованный от System.Atribute. Теперь применим его к некоторому классу:

[AgeValidation(18)]
// [AgeValidationAttribute(18)]
public class User
{
	public string Name { get; set; }
	public int Age { get; set; }
	public User (string name, int age)
	{
		Name = name;
		Age = age;
	}
}

// Пусть некоторый класс User применяет атрибут. Для этого имя атрибута указывается в квадратных скобках. Причем суффикс Attribute указывать необязательно. Обе записи [AgeValidation(18)] и [AgeValidationAttribute(18)] будут равноправны.
// Если конструктор атрибута предусматривает использование параметров (public AgeValidationAttribute(int age)), то после имени атрибута мы можем указать значения для параметров конструктора. В данном случае передается значение для параметра age. То есть фактически мы говорим, что в AgeValidationAttribute свойство Age будет иметь значение 18.
// В качестве альтернативы можно использовать именованные параметры для всех свойств атрибута, если класс атрибута имеет конструктор без параметров: [AgeValidation(Age = 18)]

// Теперь получим с помощью рефлексии атрибут класса User и используем его для проверки объектов данного класса:

class Program
{
	static bool ValidateUser(User user)
	{
		Type t = typeof(User);
		object[] attrs = t.GetCustomAttributes(false);
		foreach (AgeValidationAttribute attr in attrs)
		{
			if (user.Age >= attr.Age) return true;
			else return false;
		}
		return true;
	}
	
	static void Main()
	{
		User tom = new User("Tom", 35);
		User bob = new User("Bob", 16);
		bool tomIsValid = ValidateUser(tom);	// true
		bool bobIsValid = Validateuser(bob);	// false
		
		Console.WriteLine("Результат валидации пользователя \"{0}\": {1}", tom.Name, tomIsValid);
		Console.WriteLine("Результат валидации пользователя \"{0}\": {1}", bob.Name, bobIsValid);
	}
}

// В данном случае в методе ValidateUser через параметр получаем некоторый объект User и с помощью метода GetCustomAttributes вытаскиваем из типа User все атрибуты. Далее берем из атрибутов атрибут AgeValidationAttribute при его наличии (ведь мы можем его и не применять к классу) и проверям допустимость возраста пользователя. Если пользователь прошел проверку по возрасту, то возвращаем true, иначе возвращаем false. Если атрибут не применяется, возвращаем true.

// 												Ограничение применения атрибута

// С помощью атрибута AttributeUsage можно ограничить типы, к которым будет применяться атрибут. Например, мы хотим, чтобы выше определенный атрибут мог применяться только к классам:

[AttributeUsage(AttributeTargets.Class)]
public class RoleInfoAttribute : System.Attribute
{
	// ...
}

/*
Ограничение задает перечисление AttributeTargets, которое может принимать еще ряд значений:

	All: используется всеми типами

	Assembly: атрибут применяется к сборке

	Constructor: атрибут применяется к конструктору

	Delegate: атрибут применяется к делегату

	Enum: применяется к перечислению

	Event: атрибут применяется к событию

	Field: применяется к полю типа

	Interface: атрибут применяется к интерфейсу

	Method: применяется к методу

	Property: применяется к свойству

	Struct: применяется к структуре
*/

// С помощью логической операции ИЛИ можно комбинировать эти значения. Например, пусть атрибут может применяться к классам и структурам:

[AttrinbuteUsage(AttributeTargets.Class | AttrubuteTargets.Struct)]



