// Рефлексия представляет собой процесс выявления типов во время выполнения приложения. Каждое приложение содержит набор используемых классов, интерфейсов, а также их методов, свойств и прочих кирпичиков, из которых складывается приложение. И рефлексия как раз и позволяет определить все эти составные элементы приложения.

/* Основной функционал рефлексии сосредоточен в пространстве имен System.Reflection. В нем мы можем выделить следующие основные классы:

	Assembly: класс, представляющий сборку и позволяющий манипулировать этой сборкой

	AssemblyName: класс, хранящий информацию о сборке

	MemberInfo: базовый абстрактный класс, определяющий общий функционал для классов EventInfo, FieldInfo, MethodInfo и PropertyInfo

	EventInfo: класс, хранящий информацию о событии

	FieldInfo: хранит информацию об определенном поле типа

	MethodInfo: хранит информацию об определенном методе

	PropertyInfo: хранит информацию о свойстве

	ConstructorInfo: класс, представляющий конструктор

	Module: класс, позволяющий получить доступ к определенному модулю внутри сборки

	ParameterInfo: класс, хранящий информацию о параметре метода

*/

// Эти классы представляют составные блоки типа и приложения: методы, свойства и т.д. Но чтобы получить информацию о членах типа, нам надо воспользоваться классом System.Type.
/*
Класс System.Type представляет изучаемый тип, инкапсулируя всю информацию о нем. С помощью его свойств и методов можно получить эту информацию. Некоторые из его свойств и методов:

	Метод FindMembers() возвращает массив объектов MemberInfo данного типа

	Метод GetConstructors() возвращает все конструкторы данного типа в виде набора объектов ConstructorInfo

	Метод GetEvents() возвращает все события данного типа в виде массива объектов EventInfo

	Метод GetFields() возвращает все поля данного типа в виде массива объектов FieldInfo

	Метод GetInterfaces() получает все реализуемые данным типом интерфейсы в виде массива объектов Type

	Метод GetMembers() возвращает все члены типа в виде массива объектов MemberInfo

	Метод GetMethods() получает все методы типа в виде массива объектов MethodInfo

	Метод GetProperties() получает все свойства в виде массива объектов PropertyInfo

	Свойство Name возвращает имя типа

	Свойство Assembly возвращает название сборки, где определен тип

	Свойство Namespace возвращает название пространства имен, где определен тип

	Свойство IsArray возвращает true, если тип является массивом

	Свойство IsClass возвращает true, если тип представляет класс

	Свойство IsEnum возвращает true, если тип является перечислением

	Свойство IsInterface возвращает true, если тип представляет интерфейс

*/

// 											Получение типа
// Чтобы управлять типом и получать всю информацию о нем, нам надо сперва получить данный тип. Это можно сделать тремя способами: 
// 1. с помощью ключевого слова typeof;
// Здесь определен класс User с некоторым набором свойств и полей. И чтобы получить его тип, используется выражение Type myType = typeof(User);
class Program
{
	static void Main()
	{
		Type myType = typeof(User);
		Console.WriteLine(myType.ToString());
	}
}

class User
{
	public string Name { get; set; }
	public int Age { get; set; }
	public User(string n, int a)
	{
		Name = n;
		Age = a;
	}
	public void Display()
	{
		Console.WriteLine($"Имя: {Name}, возраст {Age}");
	}
	public int Payment(int hours, int perhour)
	{
		return hours * perhour;
	}
	
}

// 2. с помощью метода GetType() класса Object;
// В отличие от предыдущего примера здесь, чтобы получить тип, надо создавать объект класса.
User user = new User("Tom", 30);
Type myType = user.GetType();

// 3. применяя статический метод Type.GetType().
Type myType = Type.GetType("TestConsole.User", false, true);
// Первый параметр указывает на полное имя класса с пространством имен. В данном случае класс User находится в пространстве имен TestConsole. Второй параметр указывает, будет ли генерироваться исключение, если класс не удастся найти. В данном случае значение false означает, что исключение не будет генерироваться. И третий параметр указывает, надо ли учитывать регистр символов в первом параметре. Значение true означает, что регистр игнорируется.


// В данном случае класс основной программы и класс User находятся в одном проекте и компилируются в одну сборку exe. Однако может быть, что нужный нам класс находится в другой сборке dll. Для этого после полного имени класса через запятую указывается имя сборки:
Type myType = Type.GetType("TestConsole.User, MyLibrary", false, true);