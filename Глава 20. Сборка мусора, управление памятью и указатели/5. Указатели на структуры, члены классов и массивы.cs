// Указатели на типы и операция ->

// Кроме указателей на простые типы можно использовать указатели на структуры. А для доступа к полям структуры, на которую указывает указатель, используется операция ->:

class Program
{
	static void Main()
	{
		unsafe
		{
			Person person;
			person.age = 29;
			person.height = 176;
			Person* p = &person;
			p->age = 30;
			Console.WriteLine(p->age);
			
			// разыменование указателя
			(*p).height = 180;
			Console.WriteLine((*p).height);
		}
	}
}

public struct Person
{
	public int age;
	public int height;
}

// Обращаясь к указателю p->Age = 30; мы можем получить или установить значение свойства структуры, на которую указывает указатель. Обратите внимание, что просто написать p.Age=30 мы не можем, так как p - это не структура Person, а указатель на структуру.
// Альтернативой служит операция разыменования: (*p).height = 180;

// 										Указатели на массивы и stackalloc
// С помощью ключевого слова stackalloc можно выделить память под массив в стеке. Смысл выделения памяти в стеке в повышении быстродействия кода. Посмотрим на примере вычисления факториала:

unsafe
{
	const int size = 7;
	int* factorial = stackalloc int[size];	//  выделяем память в стеке под семь объектов int
	int* p = factorial;
	
	*(p++) = 1;		// присваиваем первой ячейке значение 1 и увеличиваем указатель на 1
	for (int i = 2; i <= size; i++; p++)
	{
		// считаем факториал
		*p = p[-1] *i;
	}	
	for (int i = 1; i <= size; i++)
	{
		Console.WriteLine(factorial[i-1]);
	}		
}

// Оператор stackalloc принимает после себя массив, на который будет указывать указатель. int* factorial = stackalloc int[size];.
// Для манипуляций с массивом создаем указатель p: int* p = factorial;, который указывает на первый элемент массива, в котором всего 7 элементов
// Далее начинаются уже сами операции с указателем и подсчет факториала. Так как факториал 1 равен 1, то присваиваем первому элементу, на который указывает указатель p, единицу с помощью операции разыменования: *(p++)= 1;
// Из прошлой темы мы узнали, что чтобы вложить некоторое значение по адресу, который хранит указатель, надо использовать выражение: *p=1. Но кроме этого тут происходит также инкремент указателя p++. То есть сначала первому элементу массива присваивается единица, потом указатель p смещается и начинает указывать уже на второй элемент. Мы могли бы написать это так:
*p= 1;
p++;

// Чтобы получить предыдущий элемент и сместиться назад, можно использовать операцию декремента: Console.WriteLine(*(--p));. 
//!!! Обратите внимание, что операции *(--p) и *(p--) различаются, так как в первом случае сначала идет смещение указателя, а затем его разыменовывание. А во втором случае - наоборот.

// Затем вычисляем факториал всех остальных шести чисел: *p = p[-1] *i;. Обращение к указателям как к массивам представляет альтернативу операции разыменовывания для получения значения. В данном случае мы получаем значение предыдущего элемента.

// И в заключении, используя указатель factorial, выводим факториалы всех семи чисел.

//										Оператор fixed и закрепление указателей
// Ранее мы посмотрели, как создавать указатели на типы значений, например, int или структуры. Однако кроме структур в C# есть еще и классы, которые в отличие от типов значений, помещают все связанные значения в куче. И в работу данных классов может в любой момент вмешаться сборщик мусора, периодически очищающий кучу. Чтобы фиксировать на все время работы указатели на объекты классов используется оператор fixed.
// Допустим, у нас есть класс Person:
public class Person
{
	public int age;
	public int height;
}

// Зафиксируем указатель с помощью оператора fixed:

unsafe
{
	Person person = new Person();
	person.age = 28;
	person.height = 178;
	// блок фиксации указателя
	fixed (int* p = &person.age)
	{
		if (*p < 30)
			*p = 30;
	}
	Console.WriteLine(person.age);	// 30
}

// Оператор fixed создает блок, в котором фиксируется указатель на поле объекта person. После завершения блока fixed закрепление с переменных снимается, и они могут быть подвержены сборке мусора.

// Кроме адреса переменной можно также инициализировать указатель, используя массив, строку или буфер фиксированного размера:

unsafe
{
	int[] nums = { 0, 1, 2, 3, 7, 88 };
	string str = "Привет мир";
	fixed (int* p = nums)
	{
		int thrid = *(p+2);	// получим третий элемент
		Console.WriteLine(thrid);	// 2
	}
	fixed(char* p = str)
	{
		char forth = *(p + 3);	// получим 4 элемент
		Console.WriteLine(forth);	// в
	}
}

// При инициализации указателей на строку следует учитывать, что указатель должен иметь тип char*.

// почему нигде не сказано , что создавая указатель на структуру , данная структура не должна иметь полей ссылочног типа (например string)?