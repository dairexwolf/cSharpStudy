// Если вы программировали на С/С++, то, возможно, вы знакомы с таким понятием как указатели. Указатели позволяют получить доступ к определенной ячейке памяти и произвести определенные манипуляции со значением, хранящимся в этой ячейке.

// В языке C# указатели очень редко используются, однако в некоторых случаях можно прибегать к ним для оптимизации приложений. Код, применяющий указатели, еще называют небезопасным кодом. Однако это не значит, что он представляет какую-то опасность. Просто при работе с ним все действия по использованию памяти, в том числе по ее очистке, ложится целиком на нас, а не на среду CLR. И с точки зрения CLR такой код не безопасен, так как среда не может проверить данный код, поэтому повышается вероятность различного рода ошибок.

// Чтобы использовать небезопасный код в C#, надо первым делом указать проекту, что он будет работать с небезопасным кодом. Для этого надо установить в настройках проекта соответствующий флаг - в меню Project (Проект) найти Свойства проекта. Затем в меню Build установить флажок Allow unsafe code (Разрешить небезопасный код):

// 															Ключевое слово unsafe

// Блок кода или метод, в котором используются указатели, помечается ключевым словом unsafe:

static void Main()
{
	// блок кода, использующий указатели
	unsafe
	{
		//...............................
	}
}

// Метод, использующий указатели:
unsafe private static void PointersMethod()
{
	//..........................
}

// Также с помощью unsafe можно объявлять структуры:
unsafe struct State
{
	///............................
}

// 											Операции * и &
// Ключевой при работе с указателями является операция *, которую еще называют операцией разыменовывания.
// Операция разыменовывания позволяет получить или установить значение по адресу, на который указывает указатель.

// Для получения адреса переменной применяется операция &:
static void Main()
{
	unsafe {
		int* x;	// определение указателями
		int y = 10;	// определение переменной
		
		x = &y;		// указатель x теперь указывает на адрес переменной y
		Console.WriteLine($"Переменная y = {y}; Указатель x = {*x}");
		
		y = y+20;
		Console.WriteLine("y = y + 20");
		Console.WriteLine($"Переменная y = {y}; Указатель x = {*x}");
		
		*x = 50;
		Console.WriteLine("*x = 50");
		Console.WriteLine($"Переменная y = {y}; Указатель x = {*x}");
		
	}
}

// При объявлении указателя указываем тип int* x; - в данном случае объявляется указатель на целое число. Но кроме типа int можно использовать и другие: sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal или bool. Также можно объявлять указатели на типы enum, структуры и другие указатели.

// Выражение x = &y; позволяет нам получить адрес переменной y и установить на него указатель x. До этого указатель x не на что не указывал.

// После этого все операции с y будут влиять на значение, получаемое через указатель x и наоборот, так как они указывают на одну и ту же область в памяти. Для получения значения, которое хранится в области памяти, на которую указывает указатель x, используется выражение *x.

// 												Получение адреса
// Используя преобразование указателя к целочисленному типу, можно получить адрес памяти, на который указывает указатель:

int* x;
int y = 10;

x = &y;
// получаем адрес переменной y
uint adr = (uint)x;
Console.WriteLine("Адрес переменной y: " + adr);
// Перевод в другие системы счисления
return Convert.ToString(dec,2);			//dec - переменная с числом, 2 - система счисления

//!!! Так как значение адреса - это целое число, а на 32-разрядных системах диапазон адресов 0 до 4 000 000 000, то для получения адреса используется преобразование в тип uint, long или ulong. Соответственно на 64-разрядных системах диапазон доступных адресов гораздо больше, поэтому в данном случае лучше использовать ulong, чтобы избежать ошибки переполнения.

// 												Указатель на другой указатель
// Объявление и использование указателя на указатель:

static void Main()
{
	unsafe
	{
		int* x;					// определение указателя
		int y=10;				// определяем переменную
		x = &y;					// указатель x теперь указывает на адрес переменной y
		
		int** z = &x;			// указатель z указывает на адрес, который указывает на указатель x
		**z = **z + 40;			// изменение указателя z повлечет за собой изменение переменной y
		Console.WriteLine(y);	// переменная y = 50
		Console.WriteLine(**z);	// переменная **z = 50
	}
}

