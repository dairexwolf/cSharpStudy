// Большинство объектов, используемых в программах на C#, относятся к управляемым или managed-коду, и легко очищаются сборщиком мусора. Однако вместе с тем встречаются также и такие объекты, которые задействуют неуправляемые объекты (низкоуровневые файловые дескрипторы, сетевые подключения и т.д.). Такие неуправляемые объекты обращаются к API операционной системы через службы PInvoke. Сборщик мусора может справиться с управляемыми объектами, однако он не знает, как удалять неуправляемые объекты. В этом случае разработчик должен сам реализовывать механизмы очистки на уровне программного кода.

/*
Освобождение неуправляемых ресурсов подразумевает реализацию одного из двух механизмов:

* Создание деструктора

* Реализация классом интерфейса System.IDisposable

*/

// 															Создание деструкторов
// Если вы вдруг программировали на языке C++, то наверное уже знакомы с концепцией деструкторов. Метод деструктора носит имя класса (как и конструктор), перед которым стоит знак тильды (~). Например, создадим деструктор класса Person:

public class Person
{
	public string Name { get; set; }
     
    ~Person()
    {
        Console.Beep();
        Console.WriteLine("Disposed");
    }
}

// Деструктор в отличие от конструктора не может иметь модификаторов доступа. В данном случае в деструкторе в целях демонстрации просто вызывается звуковой сигнал и выводится строка на консоль, но в реальных программах в деструктор вкладывается логика освобождения неуправляемых ресурсов.

// Однако на деле при очистке сборщик мусора вызывает не деструктор, а метод Finalize класса Person. Все потому, что компилятор C# компилирует деструктор в конструкцию, которая эквивалентна следующей:

protected override void Finallize()
{
	try
	{
		// здесь идут инструкции деструктора
	}
	finally
	{
		base.Finalize();
	}
}

// Метод Finalize уже определен в базовом для всех типов классе Object, однако данный метод нельзя так просто переопределить. И фактическая его реализация происходит через создание деструктора.

// Обратите внимание, что даже после завершения метода Test и соответственно удаления из стека ссылки на объект Person в куче, может не последовать немедленного вызова деструктора. Лишь при завершении всей программы гарантировано произойдет очистка памяти и вызов деструктора. Поэтому для более быстой очистки памяти применяется метод GC.Collect.

// На уровне памяти это выглядит так: сборщик мусора при размещении объекта в куче определяет, поддерживает ли данный объект метод Finalize. И если объект имеет метод Finalize, то указатель на него сохраняется в специальной таблице, которая называется очередь финализации. Когда наступает момент сборки мусора, сборщик видит, что данный объект должен быть уничтожен, и если он имеет метод Finalize, то он копируется в еще одну таблицу и окончательно уничтожается лишь при следующем проходе сборщика мусора.

// И здесь мы можем столкнуться со следующей проблемой: а что если нам немедленно надо вызвать деструктор и освободить все связанные с объектом неуправляемые ресурсы? В этом случае мы можем использовать второй подход - реализацию интерфейса IDisposable.

// 														Интерфейс IDisposable
// Интерфейс IDisposable объявляет один единственный метод Dispose, в котором при реализации интерфейса в классе должно происходить освобождение неуправляемых ресурсов. Например:

public class Person : IDisposable
{
	public string Name { get; set; }
	public void Dispose()
	{
		Console.Beep();
		Console.WriteLine("Disposed");
	}
}

static void Main()
{
	Test();
}

private static void Test()
{
	Person p = null;
	// В данном коде используется конструкция try...finally. По сути эта конструкция по функционалу в общем эквивалентна следующим двум строкам кода:
	// Person p = new Person(); 	p.Dispose();
	// Но конструкцию try...finally предпочтительнее использовать при вызове метода Dispose, так как она гарантирует, что даже в случае возникновения исключения произойдет освобождение ресурсов в методе Dispose.
	try
	{
		p = new Person();
	}
	finally
	{
		if (p != null)
			p.Dispose();
	}
}

//												Комбинирование подходов
// Мы рассмотрели два подхода. Какой же из них лучше? С одной стороны, метод Dispose позволяет в любой момент времени вызвать освобождение связанных ресурсов, а с другой - программист, использующий наш класс, может забыть поставить в коде вызов метода Dispose. В общем бывают различные ситуации. И чтобы сочетать плюсы обоих подходов мы можем использовать комбинированный подход. Microsoft предлагает нам использовать следующий формализованный шаблон:

public class SomeClass : IDisposable
{
	private bool disposed = false;
	
	// реализация интерфейса IDisposable
	public void Dispose()
	{
		Dispose(true);
		// подавляем  финализацию
		// Еще один важный момент - вызов в методе Dispose метода GC.SuppressFinalize(this). GC.SuppressFinalize не позволяет системе выполнить метод Finalize для данного объекта.
		GC.SuppressFinalize(this);
	}
	
	protected virtual void Dispose(bool disposing)
	{
		if (!disposed)
		{
			if (disposing)
			{
				// освобождаем управляемые ресурсы
			}
			// освобождаем неуправляемые ресурсы
			disposed = true;
		}
	}
	
	// Деструктор
	~SomeClass()
	{
		Dispose(false);
	}
}

// Логика очистки реализуется перегруженной версией метода Dispose(bool disposing). При вызове деструктора в качестве параметра disposing передается значение false, чтобы избежать очистки управляемых ресурсов, так как мы не можем быть уверенными в их состоянии, что они до сих пор находятся в памяти. И в этом случае остается полагаться на деструкторы этих ресурсов. Ну и в обоих случаях освобождаются неуправляемые ресурсы.

// Таким образом, даже если разработчик не использует в программе метод Dispose, все равно произойдет очистка и освобождение ресурсов.

// 											Общие рекомендации по использованию Finalize и Dispose
// Деструктор следует реализовывать только у тех объектов, которым он действительно необходим, так как метод Finalize оказывает сильное влияние на производительность

// После вызова метода Dispose необходимо блокировать у объекта вызов метода Finalize с помощью GC.SuppressFinalize

// При создании производных классов от базовых, которые реализуют интерфейс IDisposable, следует также вызывать метод Dispose базового класса:

public class Derived: Base
{
    private bool IsDisposed = false;
 
    protected override void Dispose(bool disposing)
    {
        if (IsDisposed) return;
        if (disposing)
        {
            // Освобождение управляемых ресурсов
        }
        IsDisposed = true;
        // Обращение к методу Dispose базового класса
        base.Dispose(disposing);
    }
}

// Отдавайте предпочтение комбинированному шаблону, реализующему как метод Dispose, так и деструктор